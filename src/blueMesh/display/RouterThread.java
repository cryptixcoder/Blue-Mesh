package blueMesh.display;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.os.Handler;

/**
 * Class used to handle connectedThreads and route data coming into
 * the connectedThreads and data generated by the user
 * @author schnej7
 *
 */
public class RouterThread extends Thread {

	private ConnectedThread connectedThreads[];
	private Handler mHandler;
	private static int connectionState;
	private ConnectionSetupThread connectionSetupThread;
	private static int radiosInUse;
	private String pairedDeviceNames[];
	private static byte messageIDs[];

	/**
	 * Make available another spot for a new connectedThread
	 * @param connectionNumber thread to kill
	 */
	public synchronized void kill_connection(int connectionNumber) {
		connectedThreads[connectionNumber] = null;
	}

	public synchronized void set_connection_state(int a_connectionState) {
		connectionState = a_connectionState;
	}

	public synchronized int get_connection_state() {
		return connectionState;
	}
	
	public synchronized long CRC_paired_names(){
		List <String> deviceNamesList = new ArrayList <String>();
		for( int i = 0; i < Constants.NUMBER_OF_AVAILABLE_RADIOS; i++){
			if( connectedThreads[i] != null){
				deviceNamesList.add(pairedDeviceNames[i]);
			}
		}
		return CrcCalculations.CalcCRC(deviceNamesList);
	}

	/**
	 * Constructor
	 * @param aHandler used to pass messages to the user
	 */
	public RouterThread(Handler aHandler) {
		mHandler = aHandler;
		connectionState = Constants.STATE_NONE;
		connectionSetupThread = null;
		radiosInUse = 0;
		connectedThreads = 
				new ConnectedThread[Constants.NUMBER_OF_AVAILABLE_RADIOS];
		pairedDeviceNames = 
				new String[Constants.NUMBER_OF_AVAILABLE_RADIOS];
		messageIDs =
				new byte[Constants.MESSAGE_QUEUE_SIZE];
		for (int i = 0; i < Constants.MESSAGE_QUEUE_SIZE; i++) {
			messageIDs[i] = 0;
		}
		for (int i = 0; i < Constants.NUMBER_OF_AVAILABLE_RADIOS; i++) {
			pairedDeviceNames[i] = "";
		}
	}

	/**
	 * Route the incoming bytes to the appropriate threads if this message
	 * has not been received before
	 * @param threadRecievedOn the thread the incoming bytes came in on
	 * @param bytes message data
	 * @param size number of bytes
	 * @return SUCCESS
	 */
	public synchronized int route_bytes(
			int threadRecievedOn, 
			byte bytes[],
			int size){
		
		for(int i = 0; i < Constants.MESSAGE_QUEUE_SIZE; i++){
			if( bytes[0] == messageIDs[i]){
				return Constants.SUCCESS;
			}
		}
		
		for(int i = 0; i < Constants.MESSAGE_QUEUE_SIZE - 1; i++){
			messageIDs[i + 1] = messageIDs[i];
		}
		messageIDs[0] = bytes[0];
		
		
		byte message[] = new byte[size - 1];
		System.arraycopy(bytes, 1, message, 0, size);
				
		// Send the obtained bytes to the UI Activity
		mHandler
		.obtainMessage(Constants.MSG_NORMAL, size - 1, -1, message)
		.sendToTarget();
		
		for(int i = 0; i < connectedThreads.length; i++){
			if(connectedThreads[i] != null && 
					connectedThreads[i].getConnectionID() != threadRecievedOn){
				connectedThreads[i].write(bytes);
			}
		}
		
		return Constants.SUCCESS;
	}

	/**
	 * Attempt to make a connection on the specified socket and device
	 * @param socket socket to connect over
	 * @param device device to connect to
	 * @return SUCCESS or FAIL
	 */
	public synchronized int make_connection(BluetoothSocket socket,
			BluetoothDevice device) {

		if (radiosInUse >= Constants.NUMBER_OF_AVAILABLE_RADIOS) {
			return Constants.FAIL;
		}

		// The connection setup thread is busy
		if (connectionState != Constants.STATE_READY) {
			return Constants.FAIL;
		}

		connectionState = Constants.STATE_BUSY;

		if (connectionSetupThread != null) {
			connectionSetupThread.cancel();
		}

		connectionSetupThread = new ConnectionSetupThread(device, this);
		connectionSetupThread.start();

		return Constants.SUCCESS;
	}

	/**
	 * Class used to establish a connection over a socket to a device
	 * @author schnej7
	 *
	 */
	private class ConnectionSetupThread extends Thread {

		private RouterThread myParent;
		private BluetoothSocket mmSocket;
		private String myName;

		// private BluetoothDevice mmDevice;

		/**
		 * Constructor
		 * @param device device to connect to
		 * @param parent reference to parent RouterThread
		 */
		public ConnectionSetupThread(
				BluetoothDevice device, 
				RouterThread parent) {
			
			myParent = parent;
			// mmDevice = device;
			BluetoothSocket tmp = null;

			// Get a BluetoothSocket for a connection with the
			// given BluetoothDevice
			try {
				tmp = device.createRfcommSocketToServiceRecord(
						Constants.MY_UUID_SECURE);
			} catch (IOException e) {
				print(Constants.MSG_DEBUG, "create() failed");
			}
			mmSocket = tmp;
			myName = device.getName();
		}

		/**
		 * Begin the attempt to connect to the device over the socket
		 * When finished a reference to the new connected thread will
		 * be in connectedThreads[]
		 */
		public void run() {
			print(Constants.MSG_DEBUG, "BEGIN ConnectionSetupThread");
			setName("ConnectThread");

			// Make a connection to the BluetoothSocket
			try {
				// This is a blocking call and will only return on a
				// successful connection or an exception
				mmSocket.connect();
			} catch (IOException e) {
				// Close the socket
				try {
					mmSocket.close();
				} catch (IOException e2) {
					print(Constants.MSG_DEBUG, "unable to close() socket during "
							+ "connection failure");
				}
				// ///////////////
				// TODO
				// connectionFailed();
				// Do something on a failed connection
				// ///////////////
				synchronized (RouterThread.this) {
					connectionState = Constants.STATE_READY;
				}
				return;
			}

			// Reset the ConnectThread because we're done
			synchronized (RouterThread.this) {
				connectionSetupThread = null;
			}

			for (int i = 0; i < Constants.NUMBER_OF_AVAILABLE_RADIOS; i++) {
				if (connectedThreads[i] == null) {
					connectedThreads[i] = new ConnectedThread(mHandler,
							myParent, i, mmSocket);
					pairedDeviceNames[i] = myName;
					connectedThreads[i].start();
					break;
				}
			}

			synchronized (RouterThread.this) {
				connectionState = Constants.STATE_READY;
			}

		}

		/**
		 * Cancel a connection attempt
		 */
		public void cancel() {
			try {
				mmSocket.close();
				synchronized (RouterThread.this) {
					connectionState = Constants.STATE_READY;
				}
			} catch (IOException e) {
				print(Constants.MSG_DEBUG, "connectionSetupThread close() failed");
			}
			
		}

	}

	/**
	 * Send a message
	 * @param message message
	 * @param mType message type
	 */
	private synchronized void print(int mType, String message){
		MessageSenderThread msThread = 
				new MessageSenderThread(mHandler, message, mType);
		msThread.start();
	}

}
